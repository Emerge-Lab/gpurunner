#include "level_gen.hpp"
#include "utils.hpp"
#include <cassert>
#include <cmath>
#include "types.hpp"

namespace {
     char randomMap[] = {'.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','@','.','.','.','@','.','@','.','.','.','.','.','.','.','.','@','.','.','.','@','.','@','@','.','.','.','.','.','.','.','.','.','.','.','@','.','@','.','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','@','@','.','.','.','@','.','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','.','@','.','.','.','@','@','.','.','.','.','.','.','.','.','.','.','.','@','@','.','@','.','.','.','.','.','.','@','.','.','@','.','.','.','.','.','.','.','.','.','.','@','.','.','@','.','@','.','.','@','@','.','.','.','.','.','.','@','.','.','.','.','@','.','.','@','@','.','.','.','.','.','.','@','.','.','@','@','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','@','.','.','.','@','.','@','.','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','@','.','.','.','@','.','.','@','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','@','@','.','.','.','@','.','@','.','.','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','@','.','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','@','.','@','.','@','.','.','.','.','.','.','.','@','.','.','.','@','.','.','.','.','.','@','.','@','.','@','@','.','@','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','@','.','.','.','@','.','.','.','.','@','@','@','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','@','.','@','.','@','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','@','.','.','.','.','.','.','.','.','@','.','.','.','.','@','.','.','@','@','@','.','.','.','.','@','.','.','@','.','.','.','.','.','.','@','@','@','.','.','@','.','@','.','.','@','.','@','.','.','@','@','.','.','.','.','@','T','@','@','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','@','.','.','@','.','.','.','.','.','.','@','@','@','.','.','.','.','.','.','@','.','.','.','@','.','.','@','.','.','@','.','@','.','.','.','@','.','.','.','@','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','@','@','.','@','.','.','.','@','.','.','.','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','.','@','.','.','@','@','@','.','.','@','@','@','.','.','.','.','.','@','.','@','.','.','@','.','.','.','.','@','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','@','.','.','.','.','.','@','.','.','.','.','@','.','.','.','@','.','@','.','@','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','@','.','@','.','.','@','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','.','.','.','.','.','.','@','.','.','@','.','.','@','.','@','.','.','.','.','.','.','@','.','@','.','.','.','.','.','.','.','.','.','@','@','.','.','.','.','.','.','.','.','.','@','.','.','@','.','.','@','.','.','@','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','@','@','.','.','.','.','.','.','@','.','.','.','@','.','.','.','@','.','.','.','.','.','.','.','.','.','@','@','@','@','.','.','.','.','@','.','.','.','.','@','.','.','.','.','@','.','@','.','@','.','.','.','@','.','.','.','.','.','.','@','@','@','@','.','@','.','.','@','@','.','@','.','@','@','.','.','.','.','.','@','.','.','.','.','.','.','.','.','@','.','.','.','.','@','@','.','.','.','.','.','.','.','.','.','.','.','.','.','@','.','.','@','.','.','.','.','.','.','.','.','.','@','.','.','.'};
  
  std::array<int32_t,20> random20 = {134,489,602,983,484,846,726,328,27,37,265,67,165,761,862,188,139,404,526,24};
}

namespace madgrid {

using namespace madrona;
using namespace madrona::math;

void createAgents(Engine& ctx) {
  std::fill(std::begin(ctx.data().agents),
	    std::end(ctx.data().agents), Entity::none());

  for (CountT idx = 0; idx < random20.size(); ++idx) {
    auto agent = ctx.makeEntity<Agent>();
    ctx.data().agents[idx++] = agent;
  }
}
  

void createPersistentEntities(Engine &ctx, Domain domain, Agents agents, Tasks tasks) {
  char* arr{nullptr};
  
  switch (domain) {
  case Domain::Random:
    arr = randomMap;
    break;
  case Domain::City:
  case Domain::Game:
  case Domain::Warehouse:
    assert(false);
  }

  for (int i = 0; i < (32*32); i++) {
    if(arr[i] == '.')
      ctx.singleton<Map>().map[i] = (int32_t)CellFlag::FreeSpace;
    else if(arr[i] == '@')
      ctx.singleton<Map>().map[i] = (int32_t)CellFlag::HardObstacle;
    else if(arr[i] == 'T')
      ctx.singleton<Map>().map[i] = (int32_t)CellFlag::Tree;
    else if(arr[i] == 'E')
      ctx.singleton<Map>().map[i] = (int32_t)CellFlag::Emitter;
    else if(arr[i] == 'S')
      ctx.singleton<Map>().map[i] = (int32_t)CellFlag::Source;
  }

  createAgents(ctx);
}

static void resetPersistentEntities(Engine &ctx) {
  for (CountT idx = 0; idx < random20.size(); ++idx) {
    Entity agent = ctx.data().agents[idx];
    if (agent == Entity::none()) {
      // This could technically be a break but better to be safe...
      continue;
    }

    // TODO: hoist out height and width
    auto location = fromRowMajor(random20[idx], 32, 32);
    // TODO: determine heading from
    auto heading = Heading::Up;
    ctx.get<Pose>(agent) = { .location = location, .heading = heading };

    // TODO: Is there a need to introduce an Action::None so as to distinguish
    // between the environment issuing a WAIT and the learning component issuing
    // a WAIT
    ctx.get<Action>(agent) = Action::Wait;
    ctx.get<Reward>(agent).r = 0.f;
    ctx.get<Done>(agent).episodeDone = 0.f;
    ctx.get<CurStep>(agent).step = 0;
    ctx.get<CollisionState>(agent) = CollisionState::None;
  }
}

static void generateLevel(Engine &ctx) {}

void generateWorld(Engine &ctx)
{
    resetPersistentEntities(ctx);
    generateLevel(ctx);
}

}

